= Inugami Project analysis maven plugin
:toc:
:source-highlighter: pygments

== Last Release:
[source,xml]
----
<dependency>
    <groupId>io.inugami.maven.plugin.analysis</groupId>
    <artifactId>inugami-project-analysis-maven-plugin</artifactId>
    <version>1.4.2</version>
</dependency>
----

== Quick start :

This maven plugin use Neo4J database to store information and resolve them.
If you haven't a Neo4J you can for test or on your local environment run a Neo4J with docker.

.docker-compose.yml
[source,yaml]
----
version: "3"
services:
  neo4j:
    image: neo4j:4.1.1
    ports:
      - "7474:7474"
      - "7473:7473"
      - "7687:7687"
    expose:
      - 7474
      - 7473
      - 7687
    environment:
      - NEO4J_AUTH=neo4j/password
      - EXTENSION_SCRIPT=/var/lib/neo4j/import/neo4j-bootstrap.sh
      - NEO4J_dbms_unmanaged__extension__classes=semantics.extension=/rdf
      - NEO4J_dbms_security_procedures_whitelist=apoc.coll.*,apoc.load.*,semantics.*
      - NEO4J_dbms_security_procedures_unrestricted=apoc.*,semantics.*
      - NEO4J_apoc_export_file_enabled=true
      - NEO4J_apoc_import_file_enabled=true
      - NEO4J_apoc_import_file_use__neo4j__config=true
    volumes:
      - ./import:/var/lib/neo4j/import
      - ./conf:/var/lib/neo4j/conf
      - ./logs:/var/lib/neo4j/logs
      - ./plugins:/var/lib/neo4j/plugins
    networks:
      - neo4j-network
networks:
  neo4j-network:
    driver: bridge
----




In your project pom.xml (or settings) we need to add some properties :

[source,xml]
----
<properties>
    <inugami.maven.plugin.analysis.project.base.name>your.base.package</inugami.maven.plugin.analysis.project.base.name>
    <inugami.maven.plugin.analysis.writer.neo4j.url>bolt://localhost:7687</inugami.maven.plugin.analysis.writer.neo4j.url>
    <inugami.maven.plugin.analysis.writer.neo4j.user>neo4j</inugami.maven.plugin.analysis.writer.neo4j.user>
    <inugami.maven.plugin.analysis.writer.neo4j.password>password</inugami.maven.plugin.analysis.writer.neo4j.password>
</properties>
----

You can also define Neo4J configuration into your maven settings :

[source,xml]
----
<servers>
    <servers>
        <id>neo4j</id>
        <username>neo4j</username>
        <password>{Yt5nGluOZ0sHzEiL7Le2IHFjtuTonkfx4yVEG3CYzZ8=}</password>
        <configuration>
            <url>bolt://localhost:7687</url>
        </configuration>
    </servers>
</servers>
----
In this case, your maven settings will overrides your pom.xml properties.


In your project build definition :
[source,xml]
----
<plugin>
    <groupId>io.inugami.maven.plugin.analysis</groupId>
    <artifactId>inugami-project-analysis-maven-plugin</artifactId>
    <version>1.4.2</version>
    <extensions>true</extensions>
    <executions>
        <execution>
            <id>check</id>
            <phase>analyze</phase>
            <goals>
                <goal>check</goal>
            </goals>
        </execution>
        <execution>
            <id>info</id>
            <phase>info</phase>
            <goals>
                <goal>retrieveInformation</goal>
            </goals>
        </execution>
    </executions>
</plugin>
----

First you need to analyse your project to send into Neo4j data :

[source,bash]
----
mvn analyze
----

image::doc/analyze-01.png[]
image::doc/analyze-02.png[]

After this analyse you can see in Neo4j your project information or execute maven phase  info

[source,bash]
----
mvn info
----
image::doc/info.png[]

This phase require to specify an action to display information

== Neo4j data structure :
image::doc/nodes.png[]


== Retrieve information :

After analyze calling, all information are present into Neo4J. We are able to create some query in Neo4J to retrieve
information. But in some commons use case is easier to invoke the plugin to display result.

Also all additional properties can be define in pom.xml properties or in common line invocation (with -D prefix).

=== restServices
One of nightmare in microservice architecture is to known interconnections between services.
What's append if I change my service ?  Who consume some service and which version is use ?
To help in this resolution, the inugami analysis plugin will analyze all Springboot Rest endpoint and feign client
to detect interdependencies between projects.

REST endpoints can be define in current project or in a transitive dependency. The plugin retrieve
transitive dependencies over 10 sub levels.
[source,bash]
----
mvn info -Daction=restServices
----
The color code is the same as Swagger, all GET endpoints are blue, green for POST, and red for DELETE.

image::doc/restServices-01.png[]

In case where some projects consume an endpoint these will be describe in the result :

image::doc/restServices-02.png[]

=== queryDisplay
Query display allow to generate a Neo4J cypher query from current projet.

[source,bash]
----
mvn info -Daction=queryDisplay
----
image::doc/queryDisplay-01.png[]

Different queries are available, so it's require to specify which one you want to use.

----
mvn info -Daction=queryDisplay -Dquery=search_services_rest
----


[source,bash]
----
mvn info -Daction=queryDisplay -Dquery=search_error_codes
----

image::doc/queryDisplay-02.png[]

=== properties
Properties action is able to display project properties. This action retrieve also dependencies properties.
Currently these properties are extract from Spring properties (@Value, bean properties, conditionals beans,
properties usages on JMS or RabbitMQ listeners)


If property have no default value, it will be display in red.
In yellow we have properties who enable some beans.
If property have bean validator constraints, these will be display too.

[source,bash]
----
mvn info -Daction=properties
----
image::doc/properties.png[]

=== queueInfo
Queue information have the same approach than restServices but for JMS and RabbitMQ.
This one is able to detect producer and listeners. It able to trace event payload and all
information on queue binding.

Like restServices, the queueInfo retrieve information over 10 levels of transitives dependencies.
[source,bash]
----
mvn info -Daction=queueInfo
----

image::doc/queue.png[]

To track correctly all JMS senders and RabbitMQ sender it's require to add annotations in your source code.

For JMS :

[source,java]
----
@JmsSender(destination = "${my.activeMq.onUserCreated.queue}", id = "create.user.queue")
public void sendCreateUser(final String someParameter, @JmsEvent final User user) {
    // process sending event
}
----

For RabbitMQ :

[source,bash]
----
@RabbitMqSender(echangeName = "${events.exchangeName}",
                queue = "${events.method.user.queueName}",
                routingKey = "${events.user.method.created.routingKey}"
)
public void fireEvent(@RabbitMqEvent  final UserCreatedEvent event) {
    // process sending event
}
----

If you use multi handler on RabbitLister you need to add annotation to specify which routing key is use :

[source,java]
----

@RabbitMqHandlerInfo(routingKey = "${events.user.authenticated.routingKey}",
typeId = "${events.user.authenticated.typeId}")
@RabbitHandler
public void onAuthenticated(final UserAuthenticatedEvent event) {
    // process listen
}
----

All specifics annotations are contains into an inugami artifact :

[source,xml]
----
<dependency>
    <groupId>io.inugami.maven.plugin.analysis</groupId>
    <artifactId>inugami-project-analysis-maven-plugin-annotations</artifactId>
    <version>${io.inugami.maven.plugin.analysis.version}</version>
</dependency>
----

This artifact contains only annotations, nothing else.

=== errorDisplay
Error management is the key for make better application. But it's require to communicate these with others teams.
Write some wiki page to describe all errors isn't the best way. It take lot of time and quickly some desynchronizations appear.
This errors list must be generate from source code.
[source,bash]
----
mvn info -Daction=errorDisplay
----


Per default Inugami plugin use the Inugami error interface to detect error code :

[source,java]
----
package io.inugami.api.exceptions;
import java.util.function.BiConsumer;

public interface ErrorCode {
    public ErrorCode getCurrentErrorCode();

    default int getStatusCode() {
        return getCurrentErrorCode() == null ? 500 : getCurrentErrorCode().getStatusCode();
    }

    default String getErrorCode() {
        return getCurrentErrorCode() == null ? "undefine" : getCurrentErrorCode().getErrorCode();
    }

    default String getMessage() {
        return getCurrentErrorCode() == null ? "error" : getCurrentErrorCode().getMessage();
    }

    default String getMessageDetail() {
        return getCurrentErrorCode() == null ? null : getCurrentErrorCode().getMessageDetail();
    }

    default String getErrorType() {
        return getCurrentErrorCode() == null ? "technical" : getCurrentErrorCode().getErrorType();
    }

    default String getPayload() {
        return getCurrentErrorCode() == null ? null : getCurrentErrorCode().getPayload();
    }

    default BiConsumer<String, Exception> getErrorHandler() {
        return getCurrentErrorCode() == null ? null : getCurrentErrorCode().getErrorHandler();
    }
}
----

This interface is contains into inugami_api artifact :
[source,xml]
----
<dependencies>
    <groupId>io.inugami</groupId>
    <artifactId>inugami_api</artifactId>
    <version>2.0.0</version>
</dependencies>
----

This interface can be use over enum types or on static class fields.
[source,java]
----
public enum IssuesError implements ErrorCode {

    ISSUES_1(newBuilder()
            .setStatusCode(400)
            .setMessage("issues request invalid")
            .setErrorType("input")),

    ISSUES_1_1(newBuilder()
            .setStatusCode(400)
            .setMessage("issue uid is mandatory")
            .setFonctionnalError());

    private final ErrorCode errorCode;

    private IssuesError(final ErrorCodeBuilder errorBuilder) {
        errorCode = errorBuilder.setErrorCode(this.name()).build();
    }

    @Override
    public ErrorCode getCurrentErrorCode() {
        return errorCode;
    }
}
----

But you can define your error code interface. In this cas it's require to add a property in your pom.xml
[source,java]
----
<properties>
   <inugami.maven.plugin.analysis.analyzer.errorCode.interface>io.inugami.demo.spring.boot.training.api.exceptions.ErrorCode</inugami.maven.plugin.analysis.analyzer.errorCode.interface>
</properties>
----

In this case the plugin will retrieve all values define in your interface.

image::doc/errorCode.png[]

.Additional configuration
|===
|Property | type | default value | description

|-Dinugami.maven.plugin.analysis.analyzer.errorCode.interface
|String
|io.inugami.api.exceptions.ErrorCode
|The error code interface to use

|-Dexport
| boolean
| false
| allow to export result as CSV files
|===

=== specificsQuery
The plugin is able to retrieve information from Neo4J and display them.
If you need to execute a specific cypher query is possible to use this plugin to do that.

[source,bash]
----
mvn info -Daction=specificsQuery -Dexport=true
----

image::doc/specificQuery.png[]

.Additional configuration
|===
|Property | type | default value | description


|-Dinugami.query.path
|String
|null
|Path to cypher query, if isn't define the plugin will ask for this one in prompt.

|-Dinugami.skip.properties
|String (Regex Pattern)
|null
|for not display some nodes properties


|-Dexport
|boolean
|false
|Allow to export result as CSV file

|===

=== importData
For import some data into Neo4J is possible to call the importData action.
This action is able to execute a cypher query or to import a JSON model.

For both it's require to specify the property *inugami.query.path* to define the import script path
[source,bash]
----
mvn info -Daction=importData
----

For cypher query is just a basic .cql script. This one must juste have for extension *.cql*

For the JSON model, is the internal plugin model as JSON :
[source,json]
----
{
  "nodes": [
    {
      "type": "String",
      "uid": "String",
      "name": "String",
      "properties": {
        "<String>": "Serializable",
        "<String>": 42
      }
    }
  ],
  "nodesToDeletes": ["String"],
  "createScripts" : ["String(Cypher)"],
  "relationships": [
    {
      "from": "String",
      "to": "String",
      "type": "String",
      "properties": {
        "<String>": "Serializable"
      }
    }
  ],
  "relationshipsToDeletes": [
    {
      "from": "String",
      "to": "String",
      "type": "String",
      "properties": {
        "<String>": "Serializable"
      }
    }
  ],
  "deleteScripts": ["String(Cypher)"]
}
----

.Additional configuration
|===
|Property | type | default value | description


|-Dinugami.query.path
|String
|null
|Path to cypher or JSON import script query, if isn't define the plugin will ask for this one in prompt.


|===
=== Deployment management

Deployment process on microservices is very complicate. It's very important to know which microservice is on which
environment.

==== publish
To be able to detect which artifact is on an environment is necessary to add information into Neo4J.
To do that is more easier to use the publish action.

[source,bash]
----
mvn info -Daction=publish
----

image::doc/publish-01.png[]

image::doc/publish-02.png[]

On *DEPLOY* we can see that the plugin have add the deployment date (on ISO date and timestamp, both are on system time zone and on UTC)
.Additional configuration
|===
|Property | type | default value | description


|-DuseMavenProject
|Boolean
| null
|Allow to use current project GAV, if null the plugin will ask for this one in prompt.

|-Denv
|String
| null
|Destination environment, if null the plugin will ask for this one in prompt.

|-DenvLevel
|int
| 0
|For sort environment it's necessary to add a weight on this one, if null the plugin will ask for this one in prompt.

|-DenvType
|String
| null
|The environment type (like DEV, INT, PREP, PROD..), if null the plugin will ask for this one in prompt.


|-DautoUnpublish
|boolean
|false
|Allow remove relationship between artifact and environment node


|-DjustThisVersion
|boolean
|false
|If you want to clean all versions relationship between artifact and environment node

|-DpreviousEnv
|boolean
|false
|For cleaning previous staging environment, if autoUnpublish is enable and this value isn't define the plugin will ask for it.
|===


==== unpublish

It's very close than publish but in this action we will remove deployments relationship on a specific version and a
environment.

[source,bash]
----
mvn info -Daction=unpublish
----

.Additional configuration
|===
|Property | type | default value | description

|-DuseMavenProject
|boolean
|false
|Allow to use current project GAV and not ask for this information

|-Denv
|String
| null
|Destination environment, if null the plugin will ask for this one in prompt.

|-DenvLevel
|int
| 0
|For sort environment it's necessary to add a weight on this one, if null the plugin will ask for this one in prompt.

|-DenvType
|String
| null
|The environment type (like DEV, INT, PREP, PROD..), if null the plugin will ask for this one in prompt.

|-DjustThisVersion
|boolean
|false
|If you want to clean all versions relationship between artifact and environment node

|===


==== versionEnv
The action versionEnv is able to verify if your project have all dependencies available on all environments.

[source,bash]
----
mvn info -Daction=versionEnv
----

In this example, the project *project-consumer* use a REST endpoint produce by *spring-boot-training-lifecycle*.
But this one isn't deploy on PREP_2. The service project *project-consumer* can't works correctly on this
environment.

Also this project use a REST endpoint `[GET]/comments/comments` but no producer have been detected

image::doc/versionEnv.png[]

.Additional configuration
|===
|Property | type | default value | description

|-Dexport
|boolean
|false
|Allow to export result as CSV file

|-DuseMavenProject
|boolean
|false
|Allow to use current project GAV and not ask for this information
|===


==== envInfo
This action is quick representation of environment deployment status. It's able to retrieve which artifacts are present
on which environments.

[source,bash]
----
mvn info -Daction=envInfo
----

image::doc/envInfo.png[]

.Additional configuration
|===
|Property | type | default value | description

|-Dexport
|boolean
|false
|Allow to export result as CSV file
|===

=== encodePassword
This action is just a small tool to encode password or sensible value in AES.


[source,bash]
----
mvn info -Daction=encodePassword
----

image::doc/password.png[]

.Additional configuration
|===
|Property | type | default value | description

|-Dinugami.maven.plugin.analysis.secret
|String (16 chars)
|null
|AES passphrase
|===

== Analyzers :

=== Feign clients
Feign clients analyzer scan all feign client interface to resolve project consuming REST endpoints;

.Properties
|===
|Property | type | default value | description

|inugami.maven.plugin.analysis.analyzer.feign.enable
|boolean
|true
|Allow to disable feign client analyzer
|===

=== SpringBoot RestControllers
To resolve project REST endpoint exposition, this analyzer scan all SpringBoot RestController.

.Properties
|===
|Property | type | default value | description

|inugami.maven.plugin.analysis.analyzer.restControllers.enable
|boolean
|true
|Allow to disable feign client analyzer
|===

=== Spring properties
Most part of issues on project come from wrong properties configuration.
This analyzer scan all properties injected by @Value annotation or Bean configuration definition.

.Properties
|===
|Property | type | default value | description

|inugami.maven.plugin.analysis.analyzer.properties.enable
|boolean
|true
|Allow to disable feign client analyzer
|===

=== ActiveMQ
For resolve activeMQ consumers and listeners, this analyzer is able to scan all Spring @JmsListener annotation.

.Properties
|===
|Property | type | default value | description

|inugami.maven.plugin.analysis.analyzer.jms.enable
|boolean
|true
|Allow to disable feign client analyzer
|===


=== Error code
For resolve activeMQ consumers and listeners, this analyzer is able to scan all Spring @JmsListener annotation.

.Properties
|===
|Property | type | default value | description

|inugami.maven.plugin.analysis.analyzer.errorCode.enable
|boolean
|true
|Allow to disable error codeanalyzer

|inugami.maven.plugin.analysis.analyzer.errorCode.interface
|String
|io.inugami.api.exceptions.ErrorCode
|Allow to specify the error code interface, configured by default with inugami error code interface

|inugami.maven.plugin.analysis.analyzer.errorCode.fieldName
|String
|errorCode
|Allow to override the default error code "field". This field is resolve with method define in error code interface. Accessor prefix is ignore
|===




